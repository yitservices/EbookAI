I also want to transfer save the response in Books and Chapters tables.

Following is my Razor view which have a button "Generate Book". It is generating book via API successfully. I need another button "Save Book" near this button to transfer APIRaw
@model EBookDashboard.Models.AIBookRequest
@{
    ViewData["Title"] = "Generate Book";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="container mt-4">
    <h2 class="mb-4">üìö Generate Book</h2>

    <div class="row mb-3">
        <div class="col-md-6">
            <label class="form-label">User ID:</label>
            <input type="text" id="UserId" class="form-control" value="123" />
        </div>
        <div class="col-md-6">
            <label class="form-label">Book ID:</label>
            <input type="text" id="BookId" class="form-control" value="456" />
        </div>
    </div>

    <div class="row mb-3">
        <div class="col-md-6">
            <label class="form-label">Number of Chapters:</label>
            <input type="text" id="Chapter" class="form-control" value="18" />
        </div>
        <div class="col-md-6">
            <label class="form-label">User Input (Topic):</label>
            <input type="text" id="UserInput" class="form-control" value="how gravity discover" />
        </div>
    </div>

    <div class="text-center mb-4">
        <button class="btn btn-primary px-4" onclick="generateBook()">
            <i class="bi bi-book"></i> Generate Book
        </button>
    </div>

    <div id="bookResult" class="mt-4"></div>
</div>

@section Scripts {
    <script>
        async function generateBook() {
            console.log("üü¢ Step 1: generateBook() function started");

            // --- Step 2: Collect input values from the page ---
           const requestData = {
                UserId: document.getElementById('UserId').value,
                BookId: document.getElementById('BookId').value,
                Chapter: parseInt(document.getElementById('Chapter').value),
                UserInput: document.getElementById('UserInput').value
            };
           console.log("üìã Step 2: Collected input data:", requestData);

            // --- Step 3: Show loading spinner on page ---
            document.getElementById('bookResult').innerHTML = `
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status"></div>
                    <p class="mt-2"><strong>Generating book...</strong></p>
                </div>`;
            console.log("‚è≥ Step 3: Displayed loading spinner");

            // --- Step 4: Send data to backend controller ---
            console.log("üöÄ Step 4: Sending POST request to /Books/AIGenerateBook");
            try {
                const response = await fetch('/Books/AIGenerateBook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                console.log("üì® Step 5: Received response:", response);

                // --- Step 5a: Handle success ---
                if (response.ok) {
                    const bookData = await response.json();
                    console.log("‚úÖ Step 6: Response converted to JSON:", bookData);
                    displayBook(bookData);
                }
                // --- Step 5b: Handle error ---
                else {
                    const errorText = await response.text();
                    console.error("‚ùå Step 6: Server returned error:", errorText);
                    document.getElementById('bookResult').innerHTML =
                        `<div class='alert alert-danger'>${errorText}</div>`;
                }
            }
            catch (error) {
                // --- Step 7: Handle network or unexpected errors ---
                console.error("üî• Step 7: Exception occurred:", error);
                document.getElementById('bookResult').innerHTML =
                    `<div class='alert alert-danger'>Error: ${error.message}</div>`;
            }
        }

        // --- Step 8: Display book content in collapsible accordion ---
        function displayBook(bookData) {
            console.log("üìñ Step 8: Displaying book on page");
            console.log("üìã Raw bookData:", bookData);

            const bookTitle = bookData.title || "Generated Book";
            const chapters = bookData.chapters || [];

            // Debug: Check the structure of the response
            console.log("üîç Chapters array:", chapters);
            console.log("üîç Response status:", bookData.status);
            console.log("üîç Full data structure:", bookData.data);

            let html = `
                <div class="card shadow-sm border-0 mb-4">
                    <div class="card-body text-center bg-light rounded">
                        <h3 class="fw-bold mb-2">${bookTitle}</h3>
                        <p class="text-muted">Total Chapters: ${chapters.length}</p>
                         <div class="alert alert-success mt-2">
                                <i class="bi bi-check-circle"></i> Book successfully generated and saved to database!
                        </div>
                    </div>
                </div>`;
                 // Show raw response for debugging
                   html += `
                    <div class="card mt-3">
                        <div class="card-header bg-warning text-dark">
                            <strong>Debug Information</strong>
                        </div>
                        <div class="card-body">
                            <pre class="mb-0">${JSON.stringify(bookData, null, 2)}</pre>
                        </div>
                    </div>`;
            if (chapters.length > 0) {
                html += `<div class="accordion" id="bookAccordion">`;

                chapters.forEach((ch, index) => {
                    const chapterId = `chapter${index}`;
                    html += `
                        <div class="accordion-item mb-2">
                            <h2 class="accordion-header" id="heading${chapterId}">
                                <button class="accordion-button ${index === 0 ? '' : 'collapsed'}"
                                        type="button" data-bs-toggle="collapse"
                                        data-bs-target="#collapse${chapterId}"
                                        aria-expanded="${index === 0}"
                                        aria-controls="collapse${chapterId}">
                                    Chapter ${index + 1}: ${ch.title || 'Untitled'}
                                </button>
                            </h2>
                            <div id="collapse${chapterId}"
                                 class="accordion-collapse collapse ${index === 0 ? 'show' : ''}"
                                 aria-labelledby="heading${chapterId}"
                                 data-bs-parent="#bookAccordion">
                                <div class="accordion-body">
                                    <p>${ch.content || 'No content available.'}</p>
                                </div>
                            </div>
                        </div>`;
                });

                html += `</div>`;
            } else {
               html += `
            <div class='alert alert-warning mt-3'>
                <strong>No chapters generated.</strong>
                <p class="mb-0">The API returned an empty chapters array. Check the debug information above.</p>
            </div>`;

            }

            document.getElementById('bookResult').innerHTML = html;
            console.log("‚úÖ Step 9: Book rendering complete!");
        }
    </script>

    <!-- Bootstrap icons (optional for nice icons) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
}

Following is my BookController.cs which successfully saving API response as it is. I also to save this data in Books and Chapters tables. While <h2> is the Chapter Title and </h2> is end of title and starting of this chapter's context. By this way a book having many chapters. 

using EBookDashboard.Interfaces;
using EBookDashboard.Models;
using EBookDashboard.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Recommendations;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using Org.BouncyCastle.Asn1.Ocsp;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace EBookDashboard.Controllers
{
    [Authorize(Roles = "Admin")]
    public class BooksController : Controller
    {
        private readonly HttpClient _httpClient;
        private readonly IBookService _bookService;
        private readonly IAPIRawResponseService _rawResponseService;
        private readonly ApplicationDbContext _context;

        public BooksController(IBookService bookService, ApplicationDbContext context, IHttpClientFactory httpClientFactory, IAPIRawResponseService rawResponseService)
        {
            _httpClient = httpClientFactory.CreateClient();
            _bookService = bookService;
            _rawResponseService = rawResponseService;
            _context = context;
        }
        // ‚úÖ 1Ô∏è‚É£ ‚Äî GET: Show the Razor view page
        [AllowAnonymous]
        [HttpGet]
        public IActionResult AIGenerateBook()
        {
            return View(); // this will look for Views/Books/AIGenerateBook.cshtml
        }

        // ‚úÖ 2Ô∏è‚É£ ‚Äî POST: Call external API and return book data as JSON
        // Generate Book via API
        [AllowAnonymous]
        [HttpPost]
        [Route("Books/AIGenerateBook")]
        public async Task<IActionResult> AIGenerateBook([FromBody] AIBookRequest model)
        {
            if (model == null)
            {
                return BadRequest("Invalid request data");
            }
            string apiUrl = "http://162.229.248.26:8001/api/generate_chapter";
            string apiKey = "X-API-Key";
            string password = "AK-proj-c8r15p0EYc1B0SKi5_hP58HEyL6xP0ywmZ2hEpvpvU5y-i7yZ8IiyLv1K7cGSkyNh";
            var responseData = string.Empty;
            int? rawResponseId = null;
            try
            {
                using var client = new HttpClient();
                {
                    // Set timeout(optional but recommended)
                    client.Timeout = TimeSpan.FromMinutes(5);

                    client.DefaultRequestHeaders.Add(apiKey, password);

                    var json = JsonConvert.SerializeObject(model);
                    var content = new StringContent(json, Encoding.UTF8, "application/json");

                    Console.WriteLine($"üì§Sending request to API: {json}");

                    var response = await client.PostAsync(apiUrl, content);
                    responseData = await response.Content.ReadAsStringAsync();

                    // Log the API response in VS Output or console
                    Console.WriteLine($"üì•API Response Status: {response.StatusCode}");
                    Console.WriteLine($"üì•API Response Data: {responseData}");

                    // ‚úÖ SAVE RAW RESPONSE FIRST
                    rawResponseId = await _rawResponseService.SaveRawResponseAsync(
                        model,
                        responseData,
                        apiUrl,
                        response.StatusCode.ToString()
                    );

                    Console.WriteLine($"üì• API Response Status: {response.StatusCode}");
                    Console.WriteLine($"üì• Raw Response saved with ID: {rawResponseId}");


                    if (!response.IsSuccessStatusCode)
                    {
                        return StatusCode((int)response.StatusCode,
                            $"API error: {response.StatusCode} - {responseData}");
                    }
                    // Parse and save to database
                    try
                    {
                        // ‚úÖ NEW: Parse the response and save to database
                        var apiResponse = JsonConvert.DeserializeObject<AIBookResponse>(responseData);
                        if (apiResponse != null)
                        {
                            Console.WriteLine($"üîç API Response has content, proceeding to save...");
                            await SaveBookToDatabase(model, apiResponse, rawResponseId);
                            Console.WriteLine("‚úÖ Book successfully saved to database");
                        }
                        else
                        {
                            Console.WriteLine("‚ö†Ô∏è No chapters to save to database");
                        }
                    }
                    catch (Exception dbEx)
                    {
                        Console.WriteLine($"‚ö†Ô∏è Database save failed but returning API response: {dbEx.Message}");
                        // Continue to return the API response even if DB save fails
                    }
                    return Content(responseData, "application/json");
                }
            }
            catch (HttpRequestException ex)
            {
                // Save error response
                if (rawResponseId == null)
                {
                    await _rawResponseService.SaveRawResponseAsync(
                        model,
                        responseData,
                        apiUrl,
                        "500",
                        $"Network error: {ex.Message}"
                    );
                }

                Console.WriteLine($"‚ùå Network error: {ex.Message}");
                return StatusCode(500, $"Network error: {ex.Message}");
            }
            catch (Exception ex)
            {
                // Save error response
                if (rawResponseId == null)
                {
                    await _rawResponseService.SaveRawResponseAsync(
                        model,
                        responseData,
                        apiUrl,
                        "500",
                        $"Unexpected error: {ex.Message}"
                    );
                }

                // Log database errors but still return the book data to user
                Console.WriteLine($"Database save error: {ex.Message}");
                // You might want to return the API response even if saving fails
                return Content(responseData, "application/json");
            }
        }
        // ‚úÖ NEW: Method to save book to database
        private async Task<bool> SaveBookToDatabase(AIBookRequest request, AIBookResponse apiResponse, int? rawResponseId = null)
        {
            Console.WriteLine("‚úÖ Trying to save Book to database");

            if (apiResponse?.Data == null || string.IsNullOrEmpty(apiResponse.Data.Content))
            {
                Console.WriteLine("‚ùå No content data in API response to save");
                return false;
            }


            using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                // Convert UserId from string to int safely
                if (!int.TryParse(request.UserId, out int userId))
                {
                    userId = 1; // Default fallback
                }
                Console.WriteLine($"üíæ Saving book to database - UserId: {userId} (converted from: {request.UserId})");

                // Create new Book
                var book = new Books
                {
                    Title = apiResponse.Title ?? $"Book - {request.UserInput}",
                    UserId = userId,
                    Status = "Generated",
                    CreatedAt = DateTime.UtcNow
                };
                Console.WriteLine($"üîç Adding book to context: {book.Title}");
                _context.Books.Add(book);
                await _context.SaveChangesAsync();
                Console.WriteLine($"üîç Book saved with ID: {book.BookId}");

                // Update raw response with the parsed book ID
                if (rawResponseId.HasValue)
                {
                    var rawResponse = await _context.APIRawResponse.FindAsync(rawResponseId.Value);
                    if (rawResponse != null)
                    {
                        rawResponse.ParsedBookId = book.BookId.ToString();
                        await _context.SaveChangesAsync();
                        Console.WriteLine($"üîç Updated raw response {rawResponseId} with book ID: {book.BookId}");
                    }
                }
                // Save the raw content as a single chapter (for now)
                var chapter = new Chapters
                {
                    BookId = book.BookId,
                    Title = "Full Book Content",
                    Content = apiResponse.Data.Content, // Save the entire raw content
                    ChapterNumber = 1
                };

                _context.Chapters.Add(chapter);
                await _context.SaveChangesAsync();

                await transaction.CommitAsync();
                Console.WriteLine($"‚úÖ SUCCESS: Book saved to database with ID: {book.BookId}");

                // Create chapters
                //var chapters = new List<Chapters>();
                //for (int i = 0; i < apiResponse.Chapters.Count; i++)
                //{
                //    var chapterResponse = apiResponse.Chapters[i];
                //    chapters.Add(new Chapters
                //    {
                //        BookId = book.BookId,
                //        Title = chapterResponse.Title ?? $"Chapter {i + 1}",
                //        Content = chapterResponse.Content,
                //        ChapterNumber = i + 1
                //    });
                //}

                //_context.Chapters.AddRange(chapters);
                //await _context.SaveChangesAsync();

                //await transaction.CommitAsync();

                //Console.WriteLine($"‚úÖ Book saved to database with ID: {book.BookId}");
                return true;
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                Console.WriteLine($"‚ùå Error saving book to database: {ex.Message}");
                return false;
            }
        }


        // GET: Books
        public async Task<IActionResult> Index()
        {
            var books = await _context.Books
                .Include(b => b.Chapters)
                .Include(b => b.BookPrice)
                .OrderByDescending(b => b.CreatedAt)
                .ToListAsync();
            return View(books);
        }

        // GET: Books/Details/5
        public async Task<IActionResult> Details(int id)
        {
            var book = await _context.Books
                .Include(b => b.Chapters)
                .Include(b => b.BookPrice)
                .FirstOrDefaultAsync(b => b.BookId == id);
            if (book == null) return NotFound();
            return View(book);
        }

        // GET: Books/Create
        public IActionResult Create()
        {
            return View();
        }

        // POST: Books/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Books book)
        {
            if (ModelState.IsValid)
            {
                book.CreatedAt = DateTime.UtcNow;
                book.Status = "Draft";
                _context.Books.Add(book);
                await _context.SaveChangesAsync();
                return RedirectToAction(nameof(Index));
            }
            return View(book);
        }

        // GET: Books/Edit/5
        public async Task<IActionResult> Edit(int id)
        {
            var book = await _context.Books.FindAsync(id);
            if (book == null) return NotFound();
            return View(book);
        }

        // POST: Books/Edit/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(int id, Books book)
        {
            if (id != book.BookId)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    book.UpdatedAt = DateTime.UtcNow;
                    _context.Update(book);
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException)
                {
                    if (!BookExists(book.BookId))
                        return NotFound();
                    else
                        throw;
                }
                return RedirectToAction(nameof(Index));
            }
            return View(book);
        }

        // GET: Books/Delete/5
        public async Task<IActionResult> Delete(int id)
        {
            var book = await _context.Books
                .Include(b => b.Chapters)
                .Include(b => b.BookPrice)
                .FirstOrDefaultAsync(b => b.BookId == id);
            if (book == null) return NotFound();
            return View(book);
        }

        // POST: Books/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(int id)
        {
            var book = await _context.Books.FindAsync(id);
            if (book != null)
            {
                _context.Books.Remove(book);
                await _context.SaveChangesAsync();
            }
            return RedirectToAction(nameof(Index));
        }

        // POST: Books/Publish/5
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Publish(int id)
        {
            var book = await _context.Books.FindAsync(id);
            if (book != null)
            {
                book.Status = "Published";
                book.UpdatedAt = DateTime.UtcNow;
                await _context.SaveChangesAsync();
            }
            return RedirectToAction(nameof(Index));
        }

        // POST: Books/Archive/5 
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Archive(int id)
        {
            var book = await _context.Books.FindAsync(id);
            if (book != null)
            {
                book.Status = "Archived";
                book.UpdatedAt = DateTime.UtcNow;
                await _context.SaveChangesAsync();
            }
            return RedirectToAction(nameof(Index));
        }

        private bool BookExists(int id)
        {
            return _context.Books.Any(e => e.BookId == id);
        }
    }
}
 
Following are modules:-

using System.ComponentModel.DataAnnotations;

namespace EBookDashboard.Models
{
    public enum BookStatus { Draft, Published, Archived }

    public class Books
    {
        [Key]
        public int BookId { get; set; }
        public int AuthorId { get; set; }
        public int UserId { get; set; }
        public int CategoryId { get; set; }


        [Required]
        [MaxLength(250)]
        public string Title { get; set; } = string.Empty;

        public string? Subtitle { get; set; }
        public string AuthorCode { get; set; } = string.Empty;
        public int LanguageId { get; set; }


        [Required]
        
        public string CoverImagePath { get; set; } = null!; // FK to AspNetUsers

        public string ManuscriptPath { get; set; } = null!; // FK to AspNetUsers

        public string Genre {  get; set; } = string.Empty;
        [StringLength(500)]
        public string? Description { get; set; }
        public int WordCount { get; set; }

        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public DateTime? UpdatedAt { get; set; }
        public string Status { get; set; } = string.Empty;

        public ICollection<Chapters> Chapters { get; set; } = new List<Chapters>();
        public ICollection<BookPrice> BookPrice { get; set; } = new List<BookPrice>();
    }

}

using System.ComponentModel.DataAnnotations;

namespace EBookDashboard.Models
{
    public class Chapters
    {
        [Required]
        [Key]
        public int ChapterId { get; set; }

        [Required]
        public int BookId { get; set; }
        public int SrNo { get; set; }
        public int ChapterNumber { get; set; }
        [Required]
        [MaxLength(200)]

        public string Title { get; set; } = string.Empty;
        public string SubTitle { get; set; } = string.Empty;

        public string Content { get; set; } = string.Empty; // the actual chapter text (can be large)
        [Required]
        public int LanguageId { get; set; }

        public int OrderIndex { get; set; } // chapter number / order
        public int WordCount { get; set; } // chapter number / order

        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
        public int UpdatedByUserId { get; set; }
        public bool IsPublished { get; set; } = false;
        public string Status { get; set; } = string.Empty;
    }

}

using System.ComponentModel.DataAnnotations;

namespace EBookDashboard.Models
{
    public class APIRawResponse
    {
        [Key]
        public int ResponseId { get; set; }

        [Required]
        public string Endpoint { get; set; }= string.Empty;

        [Required]
        public string RequestData { get; set; } = string.Empty;

        [Required]
        public string ResponseData { get; set; } = string.Empty;

        public int? UserId { get; set; }
        public int? BookId { get; set; }

        public string StatusCode { get; set; } = string.Empty;
        public string ErrorMessage { get; set; } = string.Empty;

        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        // Optional: Store the parsed book ID for reference
        public string? ParsedBookId { get; set; } = string.Empty;

    }
}



